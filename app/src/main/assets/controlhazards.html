<!DOCTYPE html>
<html>

<head>
    <link rel="stylesheet" href="stylesheet.css">
    <script src="jquery-2.1.3.js"></script>
    <script src="pipeline.js"></script>
    <script>       
       $(document).ready(function (){
            makePipeline("pipeline", 4,0,0);
            makePipeline("pipeline2", 6,1,3);
            makePipeline("pipeline3", 3,1,1,true);
            makePipeline("pipeline4", 5,1,3,true);

       });
    </script>
</head>

<body>
<a href = "Pipelining.html#startText">Instruction Execution in Pipeline</a><br>
<a href = "Pipelining2.html#startText">Parallel Execution in Pipeline</a><br>
<a href = "datahazards.html#startText">Data Hazards</a><br>
<a href = "controlhazards.html#startText">Control Hazards</a><br>
<a href = "structuralhazards.html#startText">Structural Hazards</a><br>
<a href = "MIPSControlPath.html#startText">Pipeline control path: No hazard control</a><br>
<a href = "MIPSControlPath_hazards.html#startText">Pipeline control path: Hazard control</a><br>
<h2 id = "startText">Control Hazards</h1>
    <p>Control hazards can cause a greater performance loss for the MIPS pipeline than <a href = "datahazards.html#startText">data hazards</a>. When a branch is executed, it may or may not change the PC (program counter) to something other than its current value plus 4. If a branch changes the PC to its target address, it is a taken branch; if it falls through, it is not taken.
    </p>
    <p>
        The simplest method of dealing with branches is to stall the pipeline as soon as the branch is detected, we then stall which determines the new PC. Where the stall occurs after the instruction is decoded

    </p>
    <p>
        Control hazards happen due to violations of sequential flow of program control where the culprets are Jumps and Branches
    </p>
    <p>
        Branch instructions are more frequent than Jump, thus more important to address branch penalty
    </p>

    <table><tr><td>Beq $1,$2,L </td><td rowspan = "5">
        <table id = "pipeline" cellspacing = "0" cellpadding = "0" onclick = "movePipeline('pipeline', 3, 0, 1, 1)"></table>
    </td></tr>
        <tr><td>lw</td></tr>
        <tr><td>Inst 3</td></tr>
        <tr><td>Inst 4</td></tr>

    </table>

<p>
    Now lets show you how to fix this control hazard using stalls.
</p>
    <table><tr><td>Beq </td><td rowspan = "5">
        <table id = "pipeline2" cellspacing = "0" cellpadding = "0" onclick = "movePipeline('pipeline2', 3, 0, 4, 4)"></table>
    </td></tr>
        <tr><td>stall</td></tr>
        <tr><td>stall</td></tr>
        <tr><td>stall</td></tr>
        <tr><td>lw</td></tr>
        <tr><td>Inst 3</td></tr>

    </table>

    <p>
        It is often necessary to <strong>flush</strong> the pipeline, clearing all the pipeline state registers.  This is because the pipeline may have continued past a branch operation, without taking into consideration that the branch would be taken (this could be because the compiler made an assumption, and rearranged the code accordingly, or the branch prediction was wrong).  Below is an example where the pipeline must be flushed when using the j operation:
    </p>

    <table><tr><td>j </td><td rowspan = "5">
        <table id = "pipeline3" cellspacing = "0" cellpadding = "0" onclick = "movePipeline('pipeline3', 1, 0, 2, 2)"></table>
    </td></tr>
        <tr><td>flush</td></tr>
        <tr><td>j target</td></tr>
    </table>
<br>The following is an example of flushing the pipeline when using the beq operation:<br>
    <table><tr><td>beq </td><td rowspan = "5">
        <table id = "pipeline4" cellspacing = "0" cellpadding = "0" onclick = "movePipeline('pipeline4', 3, 0, 4, 4)"></table>
    </td></tr>
        <tr><td>flush</td></tr>
        <tr><td>flush</td></tr>
        <tr><td>flush</td></tr>
        <tr><td>beq target</td></tr>
    </table>
    
    <br><br>
    Another strategy to handling control hazards is branch prediction.  The pipeline will predict whether or not a branch is taken, and, if the prediction was correct, no problem!  If the prediction was incorrect, then it is necessary to flush the pipeline.  The prediction can be static: always predict the branch is taken/not taken, or dynamic: keep 1 or 2 bit state of the most recent branches, and predict accordingly.

</body>

</html>
