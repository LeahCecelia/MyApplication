<!DOCTYPE html>
<html>

<head>
    <link rel="stylesheet" href="stylesheet.css">
    <script src="jquery-2.1.3.js"></script>
    <script src="pipeline.js"></script>
    <script>       
       $(document).ready(function (){
            makePipeline("pipeline", 2);
            makePipeline("pipeline5", 2);
            makePipeline("pipeline2", 2);
            makePipeline("pipeline3", 5, 1, 3);
            makePipeline("pipeline4", 4, 1, 2);
       });
    </script>
</head>

<body>

<a href = "Pipelining.html#startText">Instruction Execution in Pipeline</a><br>
<a href = "Pipelining2.html#startText">Parallel Execution in Pipeline</a><br>
<a href = "datahazards.html#startText">Data Hazards</a><br>
<a href = "controlhazards.html#startText">Control Hazards</a><br>
<a href = "structuralhazards.html#startText">Structural Hazards</a><br>
<a href = "MIPSControlPath.html#startText">Pipeline control path: No hazard control</a><br>
<a href = "MIPSControlPath_hazards.html#startText">Pipeline control path: Hazard control</a><br>
<h2 id = "startText">Data Hazards</h1>
Data Hazards occur when there is an attempt to use data before it is ready.  For instance, consider the following example:<br>
<table><tr><td>lw $s1, 4($sp) </td><td rowspan = "5">
        <table id = "pipeline2" cellspacing = "0" cellpadding = "0" onclick = "movePipeline('pipeline2', 4, 0, 2, 1)"></table>
    </td></tr>
        <tr><td>add $s0, $s1, $s2</td></tr>

    </table><br>
The lw instruction does not save the value at the given memory address (4 + $sp) into register $s1 until the last cycle of the instruction.  However, the next add instruction tries to read $s1 in its second cycle, which occurs before the register is written to.  To fix this, we can stall the pipeline:<br>
<table><tr><td>lw $s1, 4($sp) </td><td rowspan = "5">
        <table id = "pipeline3" cellspacing = "0" cellpadding = "0" onclick = "movePipeline('pipeline3', 4, 0, 5, 4)"></table>
    </td></tr>
        <tr><td>add $s0, $s1, $s2</td></tr>

    </table><br>
Now, there is no conflict because the register is written to before it is read from.  However, this caused 3 stalls!  It is almost as bad as executing one instruction at a time.  We can minimize stalls using a technique called <strong>data forwarding</strong>.  Notice how the data from memory is actually available after the DM stage, before being written to the register.  We could forward this data to the next instruction, so only two stalls are required:<br>
<table><tr><td>lw $s1, 4($sp) </td><td rowspan = "5">
        <table id = "pipeline4" cellspacing = "0" cellpadding = "0" onclick = "movePipeline('pipeline4', 3, 0, 4, 3)"></table>
    </td></tr>
        <tr><td>add $s0, $s1, $s2</td></tr>

    </table><br>
    To see how data forwarding is implemented in the pipeline control path, see the forwarding units in the <a href = "MIPSControlPath_hazards.html#startText"/>MIPS Control Path</a>.<br>
    
Here is an example where data forwarding actually removes all stalls:<br>

<table><tr><td>add R1, R2, R3 </td><td rowspan = "5">
    <table id = "pipeline" cellspacing = "0" cellpadding = "0" onclick = "movePipeline('pipeline', 4, 0, 2, 1)"></table>
</td></tr>
    <tr><td>sub R4, R5, R1</td></tr>
    </table>

Notice that R1 is updated, but the sub instruction tries to read from R1 before it is updated.  However, the new value of R1 is technically available after the first use of the ALU, so we can use data forwarding to move this value to the next use of the ALU, incuring zero stalls:<br>

    <table><tr><td>add R1, R2, R3 </td><td rowspan = "5">
    <table id = "pipeline5" cellspacing = "0" cellpadding = "0" onclick = "movePipeline('pipeline5', 2, 0, 3, 1)"></table>
</td></tr>
    <tr><td>sub R4, R5, R1</td></tr>
    </table>

    <ul>
        <li><a href = "datahazards.html">Data Hazards</a></li>
        <li><a href = "controlhazards.html">Control Hazards</a></li>
        <li><a href = "structuralhazards.html">Structural Hazards</a></li>
    </ul>

</body>

</html>
